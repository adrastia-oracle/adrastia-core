const { BigNumber } = require("ethers");
const { expect } = require("chai");
const { ethers } = require("hardhat");

const AddressZero = ethers.constants.AddressZero;

const USDC = "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48";
const GRT = "0xc944E90C64B2c07662A292be6244BDf05Cda44a7";

const ZERO_ACCUMULATION = [BigNumber.from(0), BigNumber.from(0), 0];

const DEFAULT_DECIMALS = 0;

async function currentBlockTimestamp() {
    const currentBlockNumber = await ethers.provider.getBlockNumber();

    return await blockTimestamp(currentBlockNumber);
}

async function blockTimestamp(blockNum) {
    return (await ethers.provider.getBlock(blockNum)).timestamp;
}

async function createDefaultAccumulator(
    quoteToken,
    tokenLiquidity,
    quoteTokenLiquidity,
    contractName = "StaticLiquidityAccumulator"
) {
    const factory = await ethers.getContractFactory(contractName);

    const accumulator = await factory.deploy(quoteToken, DEFAULT_DECIMALS, tokenLiquidity, quoteTokenLiquidity);

    return accumulator;
}

async function createDefaultAccumulatorStub(
    quoteToken,
    tokenLiquidity,
    quoteTokenLiquidity,
    contractName = "StaticLiquidityAccumulatorStub"
) {
    return await createDefaultAccumulator(quoteToken, tokenLiquidity, quoteTokenLiquidity, contractName);
}

describe("StaticLiquidityAccumulator#constructor", function () {
    var accumulator;
    var quoteToken;
    var tokenLiquidity;
    var quoteTokenLiquidity;

    beforeEach(async function () {
        quoteToken = USDC;
        tokenLiquidity = BigNumber.from(2);
        quoteTokenLiquidity = BigNumber.from(2);

        accumulator = await createDefaultAccumulator(quoteToken, tokenLiquidity, quoteTokenLiquidity);
    });

    it("Deploys correctly", async function () {
        expect(await accumulator.averagingStrategy()).to.equal(AddressZero);
        expect(await accumulator.quoteToken()).to.equal(quoteToken);
        expect(await accumulator.liquidityDecimals()).to.equal(DEFAULT_DECIMALS);
        expect(await accumulator.quoteTokenDecimals()).to.equal(DEFAULT_DECIMALS);

        expect(await accumulator.updateThreshold()).to.not.equal(0);
        expect(await accumulator.updateDelay()).to.not.equal(0);
        expect(await accumulator.heartbeat()).to.not.equal(0);
    });
});

describe("StaticLiquidityAccumulator#canUpdate", function () {
    var accumulator;
    var quoteToken;
    var tokenLiquidity;
    var quoteTokenLiquidity;

    beforeEach(async function () {
        quoteToken = USDC;
        tokenLiquidity = BigNumber.from(2);
        quoteTokenLiquidity = BigNumber.from(2);

        accumulator = await createDefaultAccumulator(quoteToken, tokenLiquidity, quoteTokenLiquidity);
    });

    it("Returns false if the token address is zero", async function () {
        var updateData = ethers.utils.defaultAbiCoder.encode(["address"], [AddressZero]);
        expect(await accumulator.canUpdate(updateData)).to.equal(false);
    });

    it("Returns false if the token address is the quote token address", async function () {
        var updateData = ethers.utils.defaultAbiCoder.encode(["address"], [USDC]);
        expect(await accumulator.canUpdate(updateData)).to.equal(false);
    });

    it("Returns false even if the token address is valid", async function () {
        var updateData = ethers.utils.defaultAbiCoder.encode(["address"], [GRT]);
        expect(await accumulator.canUpdate(updateData)).to.equal(false);
    });
});

describe("StaticLiquidityAccumulator#needsUpdate", function () {
    var accumulator;
    var quoteToken;
    var tokenLiquidity;
    var quoteTokenLiquidity;

    beforeEach(async function () {
        quoteToken = USDC;
        tokenLiquidity = BigNumber.from(2);
        quoteTokenLiquidity = BigNumber.from(2);

        accumulator = await createDefaultAccumulator(quoteToken, tokenLiquidity, quoteTokenLiquidity);
    });

    it("Returns false if the token address is zero", async function () {
        var updateData = ethers.utils.defaultAbiCoder.encode(["address"], [AddressZero]);
        expect(await accumulator.needsUpdate(updateData)).to.equal(false);
    });

    it("Returns false if the token address is the quote token address", async function () {
        var updateData = ethers.utils.defaultAbiCoder.encode(["address"], [USDC]);
        expect(await accumulator.needsUpdate(updateData)).to.equal(false);
    });

    it("Returns false even if the token address is valid", async function () {
        var updateData = ethers.utils.defaultAbiCoder.encode(["address"], [GRT]);
        expect(await accumulator.needsUpdate(updateData)).to.equal(false);
    });
});

describe("StaticLiquidityAccumulator#update", function () {
    var accumulator;
    var quoteToken;
    var tokenLiquidity;
    var quoteTokenLiquidity;

    beforeEach(async function () {
        quoteToken = USDC;
        tokenLiquidity = BigNumber.from(2);
        quoteTokenLiquidity = BigNumber.from(2);

        accumulator = await createDefaultAccumulator(quoteToken, tokenLiquidity, quoteTokenLiquidity);
    });

    async function expectNoUpdates(updateData) {
        expect(await accumulator.callStatic.update(updateData)).to.equal(false);

        const tx = await accumulator.update(updateData);
        const receipt = await tx.wait();

        expect(receipt.events).to.be.empty;
    }

    it("Doesn't update if the token address is zero", async function () {
        var updateData = ethers.utils.defaultAbiCoder.encode(["address"], [AddressZero]);
        await expectNoUpdates(updateData);
    });

    it("Doesn't update if the token address is the quote token address", async function () {
        var updateData = ethers.utils.defaultAbiCoder.encode(["address"], [USDC]);
        await expectNoUpdates(updateData);
    });

    it("Doesn't update even if the token address is valid", async function () {
        var updateData = ethers.utils.defaultAbiCoder.encode(["address"], [GRT]);
        await expectNoUpdates(updateData);
    });
});

describe("StaticLiquidityAccumulator#lastUpdateTime", function () {
    var accumulator;
    var quoteToken;
    var tokenLiquidity;
    var quoteTokenLiquidity;

    beforeEach(async function () {
        quoteToken = USDC;
        tokenLiquidity = BigNumber.from(2);
        quoteTokenLiquidity = BigNumber.from(2);

        accumulator = await createDefaultAccumulator(quoteToken, tokenLiquidity, quoteTokenLiquidity);
    });

    it("Returns the current block timestamp for the zero address", async function () {
        var updateData = ethers.utils.defaultAbiCoder.encode(["address"], [AddressZero]);
        expect(await accumulator.lastUpdateTime(updateData)).to.equal(await currentBlockTimestamp());
    });

    it("Returns the current block timestamp for the quote token", async function () {
        var updateData = ethers.utils.defaultAbiCoder.encode(["address"], [USDC]);
        expect(await accumulator.lastUpdateTime(updateData)).to.equal(await currentBlockTimestamp());
    });

    it("Returns the current block timestamp for a valid token", async function () {
        var updateData = ethers.utils.defaultAbiCoder.encode(["address"], [GRT]);
        expect(await accumulator.lastUpdateTime(updateData)).to.equal(await currentBlockTimestamp());
    });
});

describe("StaticLiquidityAccumulator#timeSinceLastUpdate", function () {
    var accumulator;
    var quoteToken;
    var tokenLiquidity;
    var quoteTokenLiquidity;

    beforeEach(async function () {
        quoteToken = USDC;
        tokenLiquidity = BigNumber.from(2);
        quoteTokenLiquidity = BigNumber.from(2);

        accumulator = await createDefaultAccumulator(quoteToken, tokenLiquidity, quoteTokenLiquidity);
    });

    it("Returns zero for the zero address", async function () {
        var updateData = ethers.utils.defaultAbiCoder.encode(["address"], [AddressZero]);
        expect(await accumulator.timeSinceLastUpdate(updateData)).to.equal(0);
    });

    it("Returns zero for the quote token", async function () {
        var updateData = ethers.utils.defaultAbiCoder.encode(["address"], [USDC]);
        expect(await accumulator.timeSinceLastUpdate(updateData)).to.equal(0);
    });

    it("Returns zero for a valid token", async function () {
        var updateData = ethers.utils.defaultAbiCoder.encode(["address"], [GRT]);
        expect(await accumulator.timeSinceLastUpdate(updateData)).to.equal(0);
    });
});

describe("StaticLiquidityAccumulator#getLastAccumulation", function () {
    var accumulator;
    var quoteToken;
    var tokenLiquidity;
    var quoteTokenLiquidity;

    beforeEach(async function () {
        quoteToken = USDC;
        tokenLiquidity = BigNumber.from(2);
        quoteTokenLiquidity = BigNumber.from(2);

        accumulator = await createDefaultAccumulator(quoteToken, tokenLiquidity, quoteTokenLiquidity);
    });

    it("Returns a valid accumulation for the zero address", async function () {
        const accumulation = [BigNumber.from(0), BigNumber.from(0), await currentBlockTimestamp()];
        const [tokenAcc, quoteTokenAcc, timestamp] = await accumulator.getLastAccumulation(AddressZero);
        expect(tokenAcc).to.equal(accumulation[0]);
        expect(quoteTokenAcc).to.equal(accumulation[1]);
        expect(timestamp).to.equal(accumulation[2]);
    });

    it("Returns a valid accumulation for the quote token", async function () {
        const accumulation = [BigNumber.from(0), BigNumber.from(0), await currentBlockTimestamp()];
        const [tokenAcc, quoteTokenAcc, timestamp] = await accumulator.getLastAccumulation(USDC);
        expect(tokenAcc).to.equal(accumulation[0]);
        expect(quoteTokenAcc).to.equal(accumulation[1]);
        expect(timestamp).to.equal(accumulation[2]);
    });

    it("Returns a valid accumulation for a valid token", async function () {
        const accumulation = [BigNumber.from(0), BigNumber.from(0), await currentBlockTimestamp()];
        const [tokenAcc, quoteTokenAcc, timestamp] = await accumulator.getLastAccumulation(GRT);
        expect(tokenAcc).to.equal(accumulation[0]);
        expect(quoteTokenAcc).to.equal(accumulation[1]);
        expect(timestamp).to.equal(accumulation[2]);
    });
});

describe("StaticLiquidityAccumulator#getCurrentAccumulation", function () {
    var accumulator;
    var quoteToken;
    var tokenLiquidity;
    var quoteTokenLiquidity;

    beforeEach(async function () {
        quoteToken = USDC;
        tokenLiquidity = BigNumber.from(2);
        quoteTokenLiquidity = BigNumber.from(2);

        accumulator = await createDefaultAccumulator(quoteToken, tokenLiquidity, quoteTokenLiquidity);
    });

    it("Returns a valid accumulation for the zero address", async function () {
        const accumulation = [BigNumber.from(0), BigNumber.from(0), await currentBlockTimestamp()];
        const [tokenAcc, quoteTokenAcc, timestamp] = await accumulator.getCurrentAccumulation(AddressZero);
        expect(tokenAcc).to.equal(accumulation[0]);
        expect(quoteTokenAcc).to.equal(accumulation[1]);
        expect(timestamp).to.equal(accumulation[2]);
    });

    it("Returns a valid accumulation for the quote token", async function () {
        const accumulation = [BigNumber.from(0), BigNumber.from(0), await currentBlockTimestamp()];
        const [tokenAcc, quoteTokenAcc, timestamp] = await accumulator.getCurrentAccumulation(USDC);
        expect(tokenAcc).to.equal(accumulation[0]);
        expect(quoteTokenAcc).to.equal(accumulation[1]);
        expect(timestamp).to.equal(accumulation[2]);
    });

    it("Returns a valid accumulation for a valid token", async function () {
        const accumulation = [BigNumber.from(0), BigNumber.from(0), await currentBlockTimestamp()];
        const [tokenAcc, quoteTokenAcc, timestamp] = await accumulator.getCurrentAccumulation(GRT);
        expect(tokenAcc).to.equal(accumulation[0]);
        expect(quoteTokenAcc).to.equal(accumulation[1]);
        expect(timestamp).to.equal(accumulation[2]);
    });
});

describe("StaticLiquidityAccumulator#calculateLiquidity", function () {
    const liquidities = [BigNumber.from(0), BigNumber.from(1), BigNumber.from(2), ethers.utils.parseUnits("1.0", 18)];

    for (const tokenLiquidity of liquidities) {
        for (const quoteTokenLiquidity of liquidities) {
            it(`Returns tokenLiquidity=${tokenLiquidity.toString()} and quoteTokenLiquidity=${quoteTokenLiquidity.toString()}`, async function () {
                const liquidity = [tokenLiquidity, quoteTokenLiquidity];
                const accumulator = await createDefaultAccumulator(USDC, tokenLiquidity, quoteTokenLiquidity);
                const [calcTokenLiquidity, calcQuoteTokenLiquidity] = await accumulator.calculateLiquidity(
                    ZERO_ACCUMULATION,
                    ZERO_ACCUMULATION
                );
                expect(calcTokenLiquidity).to.equal(tokenLiquidity);
                expect(calcQuoteTokenLiquidity).to.equal(quoteTokenLiquidity);
            });
        }
    }
});

describe("StaticLiquidityAccumulator#consultLiquidity(token)", function () {
    const tokens = [AddressZero, USDC, GRT];
    const liquidities = [BigNumber.from(0), BigNumber.from(1), BigNumber.from(2), ethers.utils.parseUnits("1.0", 18)];

    for (const token of tokens) {
        describe("token = " + token.toString(), function () {
            for (const tokenLiquidity of liquidities) {
                for (const quoteTokenLiquidity of liquidities) {
                    it(`Returns tokenLiquidity=${tokenLiquidity.toString()} and quoteTokenLiquidity=${quoteTokenLiquidity.toString()} for the zero address`, async function () {
                        const liquidity = [tokenLiquidity, quoteTokenLiquidity];
                        const accumulator = await createDefaultAccumulator(token, tokenLiquidity, quoteTokenLiquidity);
                        const [consultTokenLiquidity, consultQuoteTokenLiquidity] = await accumulator[
                            "consultLiquidity(address)"
                        ](token);
                        expect(consultTokenLiquidity).to.equal(tokenLiquidity);
                        expect(consultQuoteTokenLiquidity).to.equal(quoteTokenLiquidity);
                    });
                }
            }
        });
    }
});

describe("StaticLiquidityAccumulator#consultLiquidity(token, maxAge = 0)", function () {
    const tokens = [AddressZero, USDC, GRT];
    const liquidities = [BigNumber.from(0), BigNumber.from(1), BigNumber.from(2), ethers.utils.parseUnits("1.0", 18)];

    for (const token of tokens) {
        describe("token = " + token.toString(), function () {
            for (const tokenLiquidity of liquidities) {
                for (const quoteTokenLiquidity of liquidities) {
                    it(`Returns tokenLiquidity=${tokenLiquidity.toString()} and quoteTokenLiquidity=${quoteTokenLiquidity.toString()} for the zero address`, async function () {
                        const liquidity = [tokenLiquidity, quoteTokenLiquidity];
                        const accumulator = await createDefaultAccumulator(token, tokenLiquidity, quoteTokenLiquidity);
                        const [consultTokenLiquidity, consultQuoteTokenLiquidity] = await accumulator[
                            "consultLiquidity(address,uint256)"
                        ](token, 0);
                        expect(consultTokenLiquidity).to.equal(tokenLiquidity);
                        expect(consultQuoteTokenLiquidity).to.equal(quoteTokenLiquidity);
                    });
                }
            }
        });
    }
});

describe("StaticLiquidityAccumulator#consultLiquidity(token, maxAge = 1)", function () {
    const tokens = [AddressZero, USDC, GRT];
    const liquidities = [BigNumber.from(0), BigNumber.from(1), BigNumber.from(2), ethers.utils.parseUnits("1.0", 18)];

    for (const token of tokens) {
        describe("token = " + token.toString(), function () {
            for (const tokenLiquidity of liquidities) {
                for (const quoteTokenLiquidity of liquidities) {
                    it(`Returns tokenLiquidity=${tokenLiquidity.toString()} and quoteTokenLiquidity=${quoteTokenLiquidity.toString()} for the zero address`, async function () {
                        const liquidity = [tokenLiquidity, quoteTokenLiquidity];
                        const accumulator = await createDefaultAccumulator(token, tokenLiquidity, quoteTokenLiquidity);
                        const [consultTokenLiquidity, consultQuoteTokenLiquidity] = await accumulator[
                            "consultLiquidity(address,uint256)"
                        ](token, 1);
                        expect(consultTokenLiquidity).to.equal(tokenLiquidity);
                        expect(consultQuoteTokenLiquidity).to.equal(quoteTokenLiquidity);
                    });
                }
            }
        });
    }
});

describe("StaticLiquidityAccumulator#fetchLiquidity", function () {
    const tokens = [AddressZero, USDC, GRT];
    const liquidities = [BigNumber.from(0), BigNumber.from(1), BigNumber.from(2), ethers.utils.parseUnits("1.0", 18)];

    for (const token of tokens) {
        describe("token = " + token.toString(), function () {
            for (const tokenLiquidity of liquidities) {
                for (const quoteTokenLiquidity of liquidities) {
                    it(`Returns tokenLiquidity=${tokenLiquidity.toString()} and quoteTokenLiquidity=${quoteTokenLiquidity.toString()} for the zero address`, async function () {
                        const updateData = ethers.utils.defaultAbiCoder.encode(["address"], [token]);
                        const liquidity = [tokenLiquidity, quoteTokenLiquidity];
                        const accumulator = await createDefaultAccumulatorStub(
                            token,
                            tokenLiquidity,
                            quoteTokenLiquidity
                        );
                        const [fetchTokenLiquidity, fetchQuoteTokenLiquidity] = await accumulator.stubFetchLiquidity(
                            updateData
                        );
                        expect(fetchTokenLiquidity).to.equal(tokenLiquidity);
                        expect(fetchQuoteTokenLiquidity).to.equal(quoteTokenLiquidity);
                    });
                }
            }
        });
    }
});
